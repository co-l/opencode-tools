#!/usr/bin/env bash
# timer - Show agent thinking time for opencode sessions in the current directory
# Requires: sqlite3, opencode v1.2.0+

set -euo pipefail

# Support XDG_DATA_HOME for testing, fall back to default
DATA_DIR="${XDG_DATA_HOME:-${HOME}/.local/share/opencode}"
DB_PATH="${DATA_DIR}/opencode.db"
CWD="$(pwd)"
VERBOSE=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose) VERBOSE=true; shift ;;
        -h|--help)
            echo "Usage: timer [-v|--verbose]"
            echo "  -v, --verbose  Show detailed token breakdown with explanations"
            exit 0
            ;;
        *) shift ;;
    esac
done

# Check database exists
if [[ ! -f "$DB_PATH" ]]; then
    echo "Database not found: $DB_PATH"
    echo "Make sure you're running opencode v1.2.0+ which uses SQLite storage."
    exit 1
fi

# Format milliseconds as hh:mm:ss
format_time() {
    local ms=$1
    local total_seconds=$((ms / 1000))
    local hours=$((total_seconds / 3600))
    local minutes=$(((total_seconds % 3600) / 60))
    local seconds=$((total_seconds % 60))
    printf "%02d:%02d:%02d" "$hours" "$minutes" "$seconds"
}

# Format large numbers with commas (e.g., 125432 -> 125,432)
format_number() {
    printf "%'d" "$1"
}

# Find the most recent session for the current directory
# Returns: id|title|time_created|time_updated (pipe-separated)
find_sessions() {
    sqlite3 -separator '|' "$DB_PATH" \
        "SELECT id, title, time_created, time_updated 
         FROM session 
         WHERE directory = '$CWD' 
         ORDER BY time_updated DESC
         LIMIT 1"
}

# Calculate time spent waiting for user answers to questions
# Returns: time in ms
get_question_wait_time() {
    local msg_id=$1
    local wait_time=0
    
    # Query parts for question tool with completed status
    local results
    results=$(sqlite3 -separator '|' "$DB_PATH" \
        "SELECT 
            json_extract(data, '\$.state.time.start'),
            json_extract(data, '\$.state.time.end')
         FROM part 
         WHERE message_id = '$msg_id'
           AND json_extract(data, '\$.type') = 'tool'
           AND json_extract(data, '\$.tool') = 'question'
           AND json_extract(data, '\$.state.status') = 'completed'" 2>/dev/null) || true
    
    while IFS='|' read -r start end; do
        [[ -z "$start" || -z "$end" ]] && continue
        [[ "$end" -gt 0 && "$start" -gt 0 ]] && wait_time=$((wait_time + end - start))
    done <<< "$results"
    
    echo "$wait_time"
}

# Calculate total thinking time, prompt count, and token stats for a session
# Returns: "time_ms:prompt_count:output:reasoning:last_input:last_cache_read:cache_rebuilds"
calculate_session_stats() {
    local session_id=$1
    
    local total_ms=0
    local prompt_count=0
    local total_output=0
    local total_reasoning=0
    local last_input=0
    local last_cache_read=0
    local prev_cache_read=0
    local cache_rebuilds=0
    
    # Query all messages for this session
    local results
    results=$(sqlite3 -separator '|' "$DB_PATH" \
        "SELECT 
            id,
            json_extract(data, '\$.role'),
            json_extract(data, '\$.time.created'),
            json_extract(data, '\$.time.completed'),
            COALESCE(json_extract(data, '\$.tokens.output'), 0),
            COALESCE(json_extract(data, '\$.tokens.reasoning'), 0),
            COALESCE(json_extract(data, '\$.tokens.input'), 0),
            COALESCE(json_extract(data, '\$.tokens.cache.read'), 0),
            json_extract(data, '\$.summary.title')
         FROM message 
         WHERE session_id = '$session_id'
         ORDER BY time_created" 2>/dev/null) || true
    
    while IFS='|' read -r msg_id role time_created time_completed tok_output tok_reasoning tok_input cache_read summary_title; do
        [[ -z "$role" ]] && continue
        
        if [[ "$role" == "user" ]]; then
            # Only count real prompts (have summary.title), not !command triggers
            [[ -n "$summary_title" && "$summary_title" != "null" ]] && prompt_count=$((prompt_count + 1))
        elif [[ "$role" == "assistant" ]]; then
            # Ignore messages with no output tokens (e.g., !command results)
            [[ "${tok_output:-0}" -eq 0 ]] && continue
            
            # Accumulate output totals
            total_output=$((total_output + ${tok_output:-0}))
            total_reasoning=$((total_reasoning + ${tok_reasoning:-0}))
            
            # Detect cache rebuild (cache_read drops significantly from previous)
            if [[ "$prev_cache_read" -gt 0 && "$cache_read" -lt $((prev_cache_read - 10000)) ]]; then
                cache_rebuilds=$((cache_rebuilds + 1))
            fi
            prev_cache_read=${cache_read:-0}
            
            # Track last message's context
            last_input=${tok_input:-0}
            last_cache_read=${cache_read:-0}
            
            if [[ -n "$time_completed" && "$time_completed" != "null" && -n "$time_created" && "$time_created" != "null" ]]; then
                local duration question_time
                duration=$((time_completed - time_created))
                # Subtract time spent waiting for user answers to questions
                question_time=$(get_question_wait_time "$msg_id")
                duration=$((duration - question_time))
                [[ "$duration" -lt 0 ]] && duration=0
                total_ms=$((total_ms + duration))
            fi
        fi
    done <<< "$results"
    
    echo "${total_ms}:${prompt_count}:${total_output}:${total_reasoning}:${last_input}:${last_cache_read}:${cache_rebuilds}"
}

# Main
main() {
    local sessions
    sessions=$(find_sessions)
    
    if [[ -z "$sessions" ]]; then
        echo "No opencode session found for: $CWD"
        exit 1
    fi
    
    local count=0
    
    while IFS='|' read -r session_id title time_created time_updated; do
        [[ -z "$session_id" ]] && continue
        
        local stats
        stats=$(calculate_session_stats "$session_id")
        
        # Parse stats: time_ms:prompt_count:output:reasoning:last_input:last_cache_read:cache_rebuilds
        local total_ms prompt_count tok_output tok_reasoning last_input last_cache_read cache_rebuilds
        IFS=':' read -r total_ms prompt_count tok_output tok_reasoning last_input last_cache_read cache_rebuilds <<< "$stats"
        
        if [[ "$total_ms" -gt 0 ]]; then
            local formatted_time
            formatted_time=$(format_time "$total_ms")
            
            # Format date from timestamp
            local date_str
            date_str=$(date -d "@$((time_updated / 1000))" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "unknown")
            
            if [[ $count -gt 0 ]]; then
                echo ""
            fi
            
            echo "$formatted_time  ${prompt_count} prompts  $title"
            
            # Current context = last message's (input + cache_read)
            local current_context=$((last_input + last_cache_read))
            local cache_pct=0
            [[ "$current_context" -gt 0 ]] && cache_pct=$((last_cache_read * 100 / current_context))
            
            # Output = output + reasoning (combined work)
            local total_output=$((tok_output + tok_reasoning))
            
            # Tokens per second (output / time)
            local tokens_per_sec=0
            [[ "$total_ms" -gt 0 ]] && tokens_per_sec=$((total_output * 1000 / total_ms))
            
            if [[ "$VERBOSE" == true ]]; then
                # Verbose mode: detailed breakdown
                echo ""
                echo "         OUTPUT"
                printf "           tokens:    %s\n" "$(format_number "$tok_output")"
                if [[ "$tok_reasoning" -gt 0 ]]; then
                    printf "           reasoning: %s\n" "$(format_number "$tok_reasoning")"
                fi
                printf "           speed:     %s tok/s\n" "$(format_number "$tokens_per_sec")"
                echo ""
                echo "         CONTEXT"
                printf "           size:      %s\n" "$(format_number "$current_context")"
                printf "           cached:    %d%%\n" "$cache_pct"
                if [[ "$cache_rebuilds" -gt 0 ]]; then
                    printf "           rebuilds: %d\n" "$cache_rebuilds"
                fi
            else
                # Normal mode: compact display
                printf "         output: %s  (%s tok/s)\n" "$(format_number "$total_output")" "$(format_number "$tokens_per_sec")"
            fi
            
            echo "         ($date_str)"
            
            count=$((count + 1))
        fi
    done <<< "$sessions"
    
    if [[ $count -eq 0 ]]; then
        echo "No thinking time found for sessions in: $CWD"
    fi
}

main "$@"
